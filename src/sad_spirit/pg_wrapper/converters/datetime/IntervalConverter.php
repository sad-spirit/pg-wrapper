<?php
/**
 * Wrapper for PHP's pgsql extension providing conversion of complex DB types
 *
 * LICENSE
 *
 * This source file is subject to BSD 2-Clause License that is bundled
 * with this package in the file LICENSE and available at the URL
 * https://raw.githubusercontent.com/sad-spirit/pg-wrapper/master/LICENSE
 *
 * @package   sad_spirit\pg_wrapper
 * @copyright 2014-2017 Alexey Borzov
 * @author    Alexey Borzov <avb@php.net>
 * @license   http://opensource.org/licenses/BSD-2-Clause BSD 2-Clause license
 * @link      https://github.com/sad-spirit/pg-wrapper
 */

declare(strict_types=1);

namespace sad_spirit\pg_wrapper\converters\datetime;

use sad_spirit\pg_wrapper\{
    converters\BaseConverter,
    exceptions\TypeConversionException,
    types\DateInterval
};

/**
 * Converter for interval type
 *
 * Unfortunately PHP's DateInterval class cannot properly parse *any* of the
 * formats Postgres may use for interval output (settings 'sql_standard',
 * 'postgres', 'postgres_verbose' and 'iso_8601' for IntervalStyle config
 * parameter), so this class basically reimplements the parser used internally
 * by Postgres.
 *
 * The reimplementation is greatly simplified as it only needs to parse values
 * that can be actually generated by Postgres, it will reject some of the input
 * that Postgres will accept.
 */
class IntervalConverter extends BaseConverter
{
    /**#@+
     * Token types used by _tokenize() and _createInterval()
     */
    const TOKEN_STRING = 'string';
    const TOKEN_NUMBER = 'number';
    const TOKEN_DATE   = 'date';
    const TOKEN_TIME   = 'time';
    const TOKEN_TZ     = 'tz';
    /**#@-*/

    /**
     * Mapping of units used in 'postgres' and 'postgres_verbose' formats to DateInterval fields
     * @var array
     */
    private $_postgresUnits = [
        'd'         => 'd',
        'day'       => 'd',
        'days'      => 'd',
        'h'         => 'h',
        'hour'      => 'h',
        'hours'     => 'h',
        'hr'        => 'h',
        'hrs'       => 'h',
        'm'         => 'i',
        'min'       => 'i',
        'mins'      => 'i',
        'minute'    => 'i',
        'minutes'   => 'i',
        'mon'       => 'm',
        'mons'      => 'm',
        'month'     => 'm',
        'months'    => 'm',
        's'         => 's',
        'sec'       => 's',
        'second'    => 's',
        'seconds'   => 's',
        'secs'      => 's',
        'y'         => 'y',
        'year'      => 'y',
        'years'     => 'y',
        'yr'        => 'y',
        'yrs'       => 'y'
    ];

    /**
     * Mapping of date units in 'iso_8601' format to DateInterval fields
     * @var array
     */
    private $_iso8601DateUnits = [
        'Y' => 'y',
        'M' => 'm',
        'D' => 'd'
    ];

    /**
     * Mapping of time units in 'iso_8601' format to DateInterval fields
     * @var array
     */
    private $_iso8601TimeUnits = [
        'H' => 'h',
        'M' => 'i',
        'S' => 's'
    ];

    /**
     * Parses a string representing the fractional part of seconds
     *
     * @param string $string Should start with '.'
     * @return float
     * @throws TypeConversionException
     */
    private function _parseFractionalSecond(string $string): float
    {
        if (!is_numeric($string)) {
            throw TypeConversionException::unexpectedValue($this, 'input', 'numeric value', $string);
        }
        return (double)$string;
    }

    /**
     * Parses a string representing time, e.g. '01:02:03' or '01:02:03.45' and updates DateInterval's fields
     *
     * @param string       $token
     * @param DateInterval $interval
     * @throws TypeConversionException
     */
    private function _parseTimeToken(string $token, DateInterval $interval): void
    {
        $pos         = 0;
        $interval->h = (int)$this->getStrspn($token, '01234567890', $pos);

        $pos++;
        $minute      = $this->getStrspn($token, '01234567890', $pos);
        if (!is_numeric($minute)) {
            throw TypeConversionException::parsingFailed($this, 'numeric value', $token, $pos);
        }
        $interval->i = (int)$minute;

        if ($pos === strlen($token)) {
            $interval->s = 0;

        } elseif ('.' === ($char = $this->nextChar($token, $pos))) {
            $interval->f = $this->_parseFractionalSecond(substr($token, $pos));
            list($interval->h, $interval->i, $interval->s) = [0, $interval->h, $interval->i];

        } else {
            $pos++;
            $interval->s = (int)$this->getStrspn($token, '01234567890', $pos);
            if ($pos !== strlen($token)) {
                $interval->f = $this->_parseFractionalSecond(substr($token, $pos));
            }
        }
    }

    /**
     * Creates a DateInterval object from an array of tokens
     *
     * This is used to handle 'sql_standard', 'postgres', 'postgres_verbose'
     * output formats
     *
     * @param array $tokens
     * @return DateInterval
     * @throws TypeConversionException
     */
    private function _createInterval(array $tokens): DateInterval
    {
        // A better approach would be to clone a prototype but cloning DateInterval
        // objects does not quite work
        $interval    = new DateInterval('PT0S');
        $intervalKey = null;
        $invert      = false;
        $keysHash    = [];

        for ($i = count($tokens) - 1; $i >= 0; $i--) {
            list($tokenValue, $tokenType) = $tokens[$i];
            $keys = [];
            switch ($tokenType) {
            case self::TOKEN_TIME:
                $this->_parseTimeToken($tokenValue, $interval);
                $intervalKey = 'd';
                $keys        = ['h', 'i', 's'];
                break;

            /** @noinspection PhpMissingBreakStatementInspection */
            case self::TOKEN_TZ:
                if (false !== strchr($tokenValue, ':')) {
                    $this->_parseTimeToken(substr($tokenValue, 1), $interval);
                    if ('-' === $tokenValue[0]) {
                        list($interval->h, $interval->i, $interval->s, $interval->f) =
                            [-$interval->h, -$interval->i, -$interval->s, -$interval->f];
                    }
                    $intervalKey = 'd';
                    $keys        = ['h', 'i', 's'];
                    break;
                }
                // intentional fall-through
            case self::TOKEN_DATE:
            case self::TOKEN_NUMBER:
                if (null === $intervalKey) {
                    $intervalKey = 's';
                }
                $pos   = 1;
                // handle possible leading sign
                $sign  = $tokenValue[0];
                $value = (int)($sign . $this->getStrspn($tokenValue, '01234567890', $pos));
                $char  = isset($tokenValue[$pos]) ? $tokenValue[$pos] : false;
                if ('-' === $char) {
                    // SQL "years-months" syntax
                    $pos++;
                    $month = (int)$this->getStrspn($tokenValue, '01234567890', $pos);
                    if ($pos !== strlen($tokenValue)) {
                        throw TypeConversionException::parsingFailed($this, 'end of input', $tokenValue, $pos);
                    }
                    $interval->y = $value;
                    $interval->m = ('-' === $sign ? -$month : $month);
                    $keys        = ['y', 'm'];
                    break;

                } elseif ('.' === $char) {
                    if ('s' !== $intervalKey) {
                        throw TypeConversionException::parsingFailed(
                            $this, 'integer value', $tokenValue, $pos
                        );
                    }
                    $interval->f = $this->_parseFractionalSecond(substr($tokenValue, $pos))
                                   * ('-' === $sign ? -1 : 1);

                } elseif ($pos !== strlen($tokenValue)) {
                    throw TypeConversionException::parsingFailed(
                        $this, 'end of input', $tokenValue, $pos
                    );
                }

                $interval->{$intervalKey} = $value;
                $keys = [$intervalKey];

                break;

            case self::TOKEN_STRING:
                if ('ago' === $tokenValue) {
                    $invert = true;

                } elseif (isset($this->_postgresUnits[$tokenValue])) {
                    $intervalKey = $this->_postgresUnits[$tokenValue];

                } else {
                    throw TypeConversionException::unexpectedValue(
                        $this, 'input', 'interval unit name', $tokenValue
                    );
                }
                break;
            default:
                throw TypeConversionException::unexpectedValue(
                    $this, 'input', 'valid token type', $tokenType
                );
            }

            foreach ($keys as $key) {
                if (isset($keysHash[$key])) {
                    throw new TypeConversionException(sprintf(
                        "%s: duplicate value for interval field '%s' found",
                        __METHOD__, $key
                    ));
                }
                $keysHash[$key] = true;
            }
        }

        if ($invert) {
            $interval->invert = true;
        }

        return $interval;
    }

    /**
     * Splits an interval string in 'sql_standard', 'postgres', 'postgres_verbose' formats into tokens
     *
     * @param string $native
     * @return array
     * @throws TypeConversionException
     */
    private function _tokenize(string $native): array
    {
        $tokens = [];
        $pos    = 0;
        $length = strlen($native);

        if ('@' === $native[0]) {
            // only skip first @, there can be no other punctuation in _output_
            $pos++;
        }

        while ($pos < $length) {
            // $native cannot have _trailing_ whitespace, it was trimmed in inputNotNull()
            $pos += strspn($native, " \r\n\t\f", $pos);

            if (preg_match('/[a-z]+/A', $native, $m, 0, $pos)) {
                $field  = $m[0];
                $pos   += strlen($m[0]);
                $type   = self::TOKEN_STRING;

            } elseif (preg_match('/([+-])? \d+ (?: (:\d+)?:(\d+(\.\d+)?|\.\d+) | ([-.]) \d+ (\5\d+)? )? /Ax', $native, $m, 0, $pos)) {
                $field  = $m[0];
                $pos   += strlen($m[0]);
                if (!empty($m[1])) {
                    // has leading sign
                    $type = self::TOKEN_TZ;
                } elseif (!empty($m[3])) {
                    // has :[digit] part
                    $type = self::TOKEN_TIME;
                } elseif (!empty($m[5]) && (!empty($m[6]) || '.' !== $m[5])) {
                    // y-m or y-m-d or d.m.Y or something like that
                    $type = self::TOKEN_DATE;
                } else {
                    $type = self::TOKEN_NUMBER;
                }

            } else {
                throw TypeConversionException::parsingFailed(
                    $this, 'valid interval part', $native, $pos
                );
            }

            $tokens[] = [$field, $type];
        }

        if (empty($tokens)) {
            throw TypeConversionException::unexpectedValue($this, 'input', 'interval literal', $native);
        }

        return $tokens;
    }

    /**
     * Creates a DateInterval object from 'iso_8601' format interval string
     *
     * Unlike native DateInterval::__construct() this handles negative values
     * and fractional seconds. Only integer values are allowed for other units.
     *
     * @param string $native
     * @return DateInterval
     * @throws TypeConversionException
     */
    private function _parseISO8601(string $native): DateInterval
    {
        $interval = new DateInterval('PT0S');
        $pos      = 1;
        $length   = strlen($native);
        $isTime   = false;

        while ($pos < $length) {
            if ('T' === $native[$pos]) {
                $isTime = true;
                $pos++;
                continue;
            }
            $numpos = $pos;
            $value  = $this->getStrspn($native, '0123456789-.', $pos);
            if (!is_numeric($value)) {
                throw TypeConversionException::parsingFailed($this, 'numeric value', $native, $pos);
            }
            $unit   = $native[$pos];

            if ($isTime && isset($this->_iso8601TimeUnits[$unit])) {
                $intervalKey = $this->_iso8601TimeUnits[$unit];
            } elseif (!$isTime && isset($this->_iso8601DateUnits[$unit])) {
                $intervalKey = $this->_iso8601DateUnits[$unit];
            } else {
                throw TypeConversionException::parsingFailed($this, 'ISO 8601 interval unit', $native, $pos);
            }
            $pos++;

            if (false === ($dotPos = strpos($value, '.'))) {
                $interval->{$intervalKey} = (int)$value;
            } else {
                if ('s' !== $intervalKey) {
                    throw TypeConversionException::parsingFailed($this, 'integer value', $native, $numpos);
                }
                $interval->s = (int)substr($value, 0, $dotPos);
                $interval->f = ($interval->s >= 0 ? 1 : -1) * (double)substr($value, $dotPos);
            }
        }

        return $interval;
    }

    protected function inputNotNull(string $native)
    {
        $native = trim($native);
        if (!strlen($native)) {
            throw TypeConversionException::unexpectedValue($this, 'input', 'interval literal', $native);

        } elseif ('P' !== $native[0]) {
            return $this->_createInterval($this->_tokenize($native));

        } else {
            if (false === strpos($native, '-')) {
                // No minuses -> built-in constructor can probably handle
                try {
                    return new DateInterval($native);
                } catch (\Exception $e) {
                    // croaked; let our own parsing function work and throw an Exception
                }
            }
            return $this->_parseISO8601($native);
        }
    }

    /**
     * Converts PHP variable not identical to null into native format
     *
     * Note: a passed string will be returned as-is without any attempts to parse it.
     * PostgreSQL's interval parser accepts a lot more possible formats than this
     * class can handle.
     *
     * @param string|number|\DateInterval $value
     * @return string
     * @throws TypeConversionException
     */
    protected function outputNotNull($value): string
    {
        if (is_string($value)) {
            return $value;

        } elseif (is_int($value)) {
            return sprintf('%d seconds', $value);

        } elseif (is_float($value)) {
            return rtrim(sprintf('%.6f', $value), '.0') . ' seconds';

        } elseif ($value instanceof \DateInterval) {
            return DateInterval::formatAsISO8601($value);
        }

        throw TypeConversionException::unexpectedValue(
            $this, 'output', 'a string, a number or an instance of DateInterval', $value
        );
    }
}
